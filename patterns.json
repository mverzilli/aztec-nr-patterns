{
  "title": "A Pattern Language for Aztec-nr",
  "subtitle": "Privacy-Preserving Smart Contract Development in Noir",
  "authors": [
    "The Aztec Team"
  ],
  "scales": [
    {
      "id": "system",
      "name": "System Architecture",
      "description": "Patterns shaping the dual-execution, privacy-preserving blockchain model",
      "range": [
        1,
        10
      ]
    },
    {
      "id": "framework",
      "name": "Framework Abstractions",
      "description": "Patterns for the core abstractions that contract developers use daily",
      "range": [
        11,
        25
      ]
    },
    {
      "id": "implementation",
      "name": "Implementation",
      "description": "Patterns at the code level: macros, conventions, and techniques",
      "range": [
        26,
        40
      ]
    }
  ],
  "patterns": [
    {
      "number": 1,
      "name": "Dual Execution Model",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "system",
      "tags": [
        "architecture",
        "execution",
        "privacy",
        "public"
      ],
      "problem": "A blockchain that executes everything publicly leaks all user data, but a blockchain that executes everything privately cannot support shared mutable state. The system needs both modes, but combining them introduces fundamental asymmetries in timing, visibility, and guarantees.",
      "contains": [
        11,
        12,
        18
      ],
      "contained_by": []
    },
    {
      "number": 2,
      "name": "UTXO-Based Private State",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "system",
      "tags": [
        "privacy",
        "state",
        "notes",
        "utxo"
      ],
      "problem": "An account model for private state (like Solidity's storage slots) would require a global view of all state to verify transitions, destroying privacy. The system needs a way to represent private state that can be created, read, and destroyed without revealing its contents or existence to other users.",
      "contains": [
        14,
        16,
        17
      ],
      "contained_by": []
    },
    {
      "number": 3,
      "name": "Kernel Siloing",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "system",
      "tags": [
        "security",
        "isolation",
        "hashing",
        "kernel"
      ],
      "problem": "If two contracts independently create notes with the same hash, or if a malicious contract can produce nullifiers that collide with another contract's notes, the integrity of private state collapses.",
      "contains": [],
      "contained_by": []
    },
    {
      "number": 4,
      "name": "Asynchronous Cross-Domain Messaging",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "system",
      "tags": [
        "execution",
        "async",
        "enqueue",
        "cross-domain"
      ],
      "problem": "Private functions execute on the user's device against historical state, while public functions execute on the block proposer against current state. A private function cannot synchronously call a public function because it would need access to state that does not yet exist from its perspective.",
      "contains": [
        27,
        31
      ],
      "contained_by": []
    },
    {
      "number": 5,
      "name": "Privacy-Preserving State Discovery",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "system",
      "tags": [
        "privacy",
        "discovery",
        "oracle",
        "pxe"
      ],
      "problem": "In a privacy-preserving system, the blockchain stores only hashes of private state. But the user's client must somehow learn which notes it owns without asking the network to reveal them.",
      "contains": [
        16,
        17
      ],
      "contained_by": []
    },
    {
      "number": 11,
      "name": "Context-Aware Type System",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "framework",
      "tags": [
        "types",
        "generics",
        "safety",
        "compile-time"
      ],
      "problem": "A developer might accidentally read public mutable state from a private function, or attempt to create notes in a public context. These errors are subtle and would produce cryptographically invalid proofs at runtime -- far too late to catch.",
      "contains": [
        13,
        30
      ],
      "contained_by": [
        1
      ]
    },
    {
      "number": 12,
      "name": "The Self Object",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "framework",
      "tags": [
        "interface",
        "abstraction",
        "contract",
        "ergonomics"
      ],
      "problem": "Contract functions need access to storage, the execution context, the contract's own address, and the ability to call other contracts or emit events. Passing all of these as separate parameters would be verbose and error-prone.",
      "contains": [
        27
      ],
      "contained_by": [
        1
      ]
    },
    {
      "number": 13,
      "name": "State Variable Hierarchy",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "framework",
      "tags": [
        "storage",
        "state",
        "traits",
        "hierarchy"
      ],
      "problem": "The dual-execution model demands different storage semantics for public and private state, yet contracts need a uniform way to declare and organize their storage. Without a shared abstraction, each state variable type would require its own initialization and slot-assignment logic.",
      "contains": [
        14,
        15
      ],
      "contained_by": [
        11
      ]
    },
    {
      "number": 14,
      "name": "Owned State Containers",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "framework",
      "tags": [
        "ownership",
        "state",
        "notes",
        "per-user"
      ],
      "problem": "Private state variables hold notes that belong to specific owners, but the storage system assigns a single base slot per field. Without a way to scope private state by owner, every user's notes would share the same storage slot, making retrieval inefficient and semantics unclear.",
      "contains": [],
      "contained_by": [
        2,
        13
      ]
    },
    {
      "number": 15,
      "name": "Storage Slot Derivation",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "framework",
      "tags": [
        "storage",
        "hashing",
        "slots",
        "map"
      ],
      "problem": "A mapping from keys to values needs a way to assign unique storage slots to each key-value pair. Using sequential numbering would require knowing all keys in advance, which is impossible for open-ended mappings like user balances.",
      "contains": [],
      "contained_by": [
        13
      ]
    },
    {
      "number": 16,
      "name": "Note Lifecycle",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "framework",
      "tags": [
        "notes",
        "lifecycle",
        "create",
        "destroy",
        "nullify"
      ],
      "problem": "Notes are the atoms of private state, but they have a non-trivial lifecycle: creation, retrieval, and destruction each involve different cryptographic operations and different interactions with the kernel and PXE.",
      "contains": [],
      "contained_by": [
        2,
        5
      ]
    },
    {
      "number": 17,
      "name": "Explicit Delivery",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "framework",
      "tags": [
        "notes",
        "delivery",
        "encryption",
        "privacy",
        "intentionality"
      ],
      "problem": "A created note is useless to its owner until the owner's PXE discovers it. If the framework silently handled delivery, developers might not realize that a missing or misconfigured delivery means the recipient can never access their state.",
      "contains": [],
      "contained_by": [
        2,
        5
      ]
    },
    {
      "number": 18,
      "name": "Event Emission Protocol",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "framework",
      "tags": [
        "events",
        "logging",
        "privacy",
        "encryption"
      ],
      "problem": "Contracts need to emit observable side-effects for off-chain indexing, but in a privacy-preserving system, events must support both encrypted (private) and transparent (public) emission modes.",
      "contains": [],
      "contained_by": [
        1
      ]
    },
    {
      "number": 19,
      "name": "Authorization Witnesses",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "framework",
      "tags": [
        "authorization",
        "authentication",
        "accounts",
        "delegation"
      ],
      "problem": "In a privacy-preserving system, the traditional `msg.sender` check for authorization is insufficient. A user might want to authorize a specific action without being the direct caller, or delegate authority to a contract acting on their behalf.",
      "contains": [],
      "contained_by": []
    },
    {
      "number": 26,
      "name": "Macro-Driven Contract Definition",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "implementation",
      "tags": [
        "macros",
        "codegen",
        "boilerplate",
        "aztec-macro"
      ],
      "problem": "A privacy-preserving smart contract requires substantial boilerplate: note hash and nullifier computation dispatch, state synchronization entry points, message decryption logic, and ABI exports. Writing this by hand for every contract would be error-prone and tedious.",
      "contains": [
        27,
        30
      ],
      "contained_by": []
    },
    {
      "number": 27,
      "name": "Generated Calling Interfaces",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "implementation",
      "tags": [
        "codegen",
        "cross-contract",
        "type-safety",
        "calls"
      ],
      "problem": "Cross-contract calls require encoding function selectors and arguments correctly. Manual encoding is fragile -- a mistyped selector or wrong argument order produces silent failures or invalid proofs.",
      "contains": [],
      "contained_by": [
        4,
        12,
        26
      ]
    },
    {
      "number": 28,
      "name": "Initialization Guards",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "implementation",
      "tags": [
        "initialization",
        "constructor",
        "nullifier",
        "safety"
      ],
      "problem": "A contract that can be initialized multiple times is vulnerable to state reset attacks. But in a privacy-preserving system, simply checking a boolean flag in public storage would leak information about the contract's initialization status.",
      "contains": [],
      "contained_by": []
    },
    {
      "number": 29,
      "name": "Function Annotation Convention",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "implementation",
      "tags": [
        "macros",
        "annotations",
        "functions",
        "convention"
      ],
      "problem": "A contract contains functions with fundamentally different execution semantics: private, public, utility, internal, initializer, view-only. Without a clear classification system, it is ambiguous which functions can be called externally and in which execution context.",
      "contains": [],
      "contained_by": [
        11,
        26
      ]
    },
    {
      "number": 30,
      "name": "Packable Serialization",
      "confidence": 2,
      "confidence_label": "Invariant",
      "scale": "implementation",
      "tags": [
        "serialization",
        "storage",
        "fields",
        "traits"
      ],
      "problem": "Blockchain state is ultimately stored as arrays of finite field elements, but contract developers work with structured types (structs, integers, addresses). The system needs a uniform way to convert between structured types and field arrays for storage and hashing.",
      "contains": [],
      "contained_by": []
    },
    {
      "number": 31,
      "name": "Partial Notes",
      "confidence": 1,
      "confidence_label": "Progressing",
      "scale": "implementation",
      "tags": [
        "notes",
        "cross-domain",
        "partial",
        "advanced"
      ],
      "problem": "Some operations require a value that is only known after public execution, but the note must be created in private context. Neither domain alone has all the information needed to create the complete note.",
      "contains": [],
      "contained_by": [
        4
      ]
    }
  ]
}